rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    function isAdmin() {
      return isAuthenticated() && 
        request.auth.token.admin == true;
    }
    
    function isAdminByEmail() {
      return isAuthenticated() &&
        (request.auth.token.email == 'ribt2218@gmail.com' ||
         request.auth.token.email == 'rohan@linkstudio.ai');
    }
    
    function isAdminUser() {
      return isAdmin() || isAdminByEmail();
    }
    
    function isMeetingParticipant(meetingId) {
      return isAuthenticated() &&
        (get(/databases/$(database)/documents/meetings/$(meetingId)).data.hostId == request.auth.uid ||
         request.auth.uid in get(/databases/$(database)/documents/meetings/$(meetingId)).data.participantIds);
    }
    
    function isMeetingHost(meetingId) {
      return isAuthenticated() &&
        get(/databases/$(database)/documents/meetings/$(meetingId)).data.hostId == request.auth.uid;
    }
    
    function isValidVoiceData() {
      return request.resource.data.keys().hasAll(['confirmed', 'confidence']) &&
        request.resource.data.confidence is number &&
        request.resource.data.confidence >= 0 &&
        request.resource.data.confidence <= 1;
    }
    
    // Users collection (Enhanced)
    match /users/{userId} {
      // Read: User can read own data, admins can read all, others can read basic info
      allow read: if isOwner(userId) || isAdminUser() ||
        (isAuthenticated() && resource.data.keys().hasOnly(['displayName', 'email']));
      
      // Write: User can write own data, admin can write any
      allow write: if isOwner(userId) || isAdminUser();
      
      // Voice profiles subcollection (legacy - use voice_library instead)
      match /voiceProfiles/{profileId} {
        allow read: if isOwner(userId);
        allow write: if isOwner(userId);
      }
    }
    
    // Voice Library collection - Core voice identification data
    match /voice_library/{deepgramVoiceId} {
      // Read: Allow authenticated users to read voices for identification workflow
      // Enhanced with better error handling and fallback access
      allow read: if isAuthenticated() && (
        // Owner can always read
        resource.data.userId == request.auth.uid ||
        // Admin can always read (with fallback email check)
        isAdminUser() ||
        // Allow reading unconfirmed voices for speaker identification
        resource.data.confirmed == false ||
        // Allow reading confirmed voices for meeting participation
        resource.data.confirmed == true
      );
      
      // Create: Allow authenticated users to create voice entries with validation
      allow create: if isAuthenticated() &&
        isValidVoiceData() &&
        (
          // Either no userId specified (system created)
          !('userId' in request.resource.data) || 
          // Or user is creating their own entry
          request.resource.data.userId == request.auth.uid ||
          // Or userId is null (pending identification)
          request.resource.data.userId == null ||
          // Or admin is creating entry
          isAdminUser()
        );
      
      // Update: Enhanced with better permission checking
      allow update: if isAuthenticated() &&
        isValidVoiceData() &&
        (
          // Owner can update their own voice
          resource.data.userId == request.auth.uid ||
          // Admin can update any voice
          isAdminUser() ||
          // Anyone can identify unconfirmed voices by claiming ownership
          (resource.data.confirmed == false && 
           request.resource.data.userId == request.auth.uid &&
           request.resource.data.confirmed == true)
        );
      
      // Delete: Only owner or admin with fallback
      allow delete: if isAuthenticated() &&
        (
          resource.data.userId == request.auth.uid || 
          isAdminUser()
        );
    }
    
    // Needs Identification collection - Pending speaker identification requests
    match /needs_identification/{requestId} {
      // Read: Host of the meeting, admins, or participants can read
      allow read: if isAuthenticated() &&
        (resource.data.hostId == request.auth.uid ||
         isMeetingParticipant(resource.data.meetingId) ||
         isAdminUser());
      
      // Create: Meeting participants can create identification requests
      allow create: if isAuthenticated() &&
        request.resource.data.keys().hasAll(['meetingId', 'hostId', 'voiceId']) &&
        isMeetingParticipant(request.resource.data.meetingId);
      
      // Update: Host can update (for resolving), original creator can update
      allow update: if isAuthenticated() &&
        (resource.data.hostId == request.auth.uid ||
         isMeetingHost(resource.data.meetingId) ||
         isAdminUser());
      
      // Delete: Host or admin only
      allow delete: if isAuthenticated() &&
        (resource.data.hostId == request.auth.uid || isAdminUser());
    }
    
    // Meeting Types collection - Meeting configurations
    match /meeting_types/{typeId} {
      // Read: Owner, regular participants, or admin
      allow read: if isAuthenticated() &&
        (resource.data.ownerId == request.auth.uid ||
         request.auth.uid in resource.data.regularParticipants ||
         isAdminUser());
      
      // Create: Authenticated users can create their own meeting types
      allow create: if isAuthenticated() &&
        request.resource.data.ownerId == request.auth.uid &&
        request.resource.data.keys().hasAll(['name', 'ownerId', 'systemPrompt']);
      
      // Update: Only owner can update
      allow update: if isAuthenticated() &&
        resource.data.ownerId == request.auth.uid;
      
      // Delete: Only owner can delete
      allow delete: if isAuthenticated() &&
        resource.data.ownerId == request.auth.uid;
    }
    
    // Voice Matches collection - Cached voice matching data
    match /voice_matches/{deepgramVoiceId} {
      // Read: If user is the confirmed user or admin
      allow read: if isAuthenticated() &&
        (resource.data.confirmedUserId == request.auth.uid || isAdminUser());
      
      // Write: System updates only (via admin or cloud functions)
      allow write: if isAdminUser();
    }
    
    // Meetings collection (Enhanced)
    match /meetings/{meetingId} {
      // Read: Host, participants, or admin with enhanced error handling
      allow read: if isAuthenticated() && 
        (resource.data.hostId == request.auth.uid ||
         request.auth.uid in resource.data.participantIds ||
         isAdminUser());
      
      // Create: Authenticated users can create meetings
      allow create: if isAuthenticated() &&
        request.resource.data.hostId == request.auth.uid &&
        request.resource.data.keys().hasAll(['hostId', 'title', 'status']);
      
      // Update: Host can update, participants can update limited fields
      allow update: if isAuthenticated() && 
        (resource.data.hostId == request.auth.uid ||
         (request.auth.uid in resource.data.participantIds &&
          // Participants can only update transcript and participant data
          request.resource.data.diff(resource.data).affectedKeys()
            .hasOnly(['transcript', 'participants', 'currentModel', 'modelContext'])));
      
      // Delete: Only host can delete
      allow delete: if isAuthenticated() && 
        resource.data.hostId == request.auth.uid;
        
      // Notes subcollection
      match /notes/{noteId} {
        allow read, write: if isAuthenticated() &&
          (get(/databases/$(database)/documents/meetings/$(meetingId)).data.hostId == request.auth.uid ||
           request.auth.uid in get(/databases/$(database)/documents/meetings/$(meetingId)).data.participantIds);
      }
      
      // Transcripts subcollection
      match /transcripts/{transcriptId} {
        allow read: if isAuthenticated() &&
          (get(/databases/$(database)/documents/meetings/$(meetingId)).data.hostId == request.auth.uid ||
           request.auth.uid in get(/databases/$(database)/documents/meetings/$(meetingId)).data.participantIds);
        allow write: if isAuthenticated() &&
          (get(/databases/$(database)/documents/meetings/$(meetingId)).data.hostId == request.auth.uid ||
           request.auth.uid in get(/databases/$(database)/documents/meetings/$(meetingId)).data.participantIds);
        
        // Transcript entries nested collection
        match /entries/{entryId} {
          allow read, write: if isAuthenticated() &&
            (get(/databases/$(database)/documents/meetings/$(meetingId)).data.hostId == request.auth.uid ||
             request.auth.uid in get(/databases/$(database)/documents/meetings/$(meetingId)).data.participantIds);
        }
      }
      
      // Speakers subcollection
      match /speakers/{speakerId} {
        allow read, write: if isAuthenticated() &&
          (get(/databases/$(database)/documents/meetings/$(meetingId)).data.hostId == request.auth.uid ||
           request.auth.uid in get(/databases/$(database)/documents/meetings/$(meetingId)).data.participantIds);
      }
      
      // Analytics subcollection for meetings
      match /analytics/{analyticsId} {
        allow read: if isAuthenticated() &&
          (get(/databases/$(database)/documents/meetings/$(meetingId)).data.hostId == request.auth.uid ||
           request.auth.uid in get(/databases/$(database)/documents/meetings/$(meetingId)).data.participantIds);
        allow write: if isAuthenticated() &&
          get(/databases/$(database)/documents/meetings/$(meetingId)).data.hostId == request.auth.uid;
      }
    }
    
    // Audio clips collection
    match /audioClips/{clipId} {
      allow read: if isAuthenticated();
      allow write: if isAuthenticated();
    }
    
    // Custom rules collection
    match /customRules/{ruleId} {
      allow read: if isAuthenticated() && 
        (resource.data.userId == request.auth.uid || resource.data.isPublic == true);
      allow write: if isAuthenticated() && 
        resource.data.userId == request.auth.uid;
    }
    
    // Agent configurations
    match /agents/{agentId} {
      allow read: if isAuthenticated();
      allow write: if isAdminUser();
    }
    
    // TTS cache collection
    match /ttsCache/{cacheId} {
      allow read: if isAuthenticated();
      allow write: if isAuthenticated();
      allow delete: if isAuthenticated();
    }
    
    // Cost tracking collections
    match /costs/{userId} {
      allow read: if isOwner(userId) || isAdminUser();
      allow write: if isOwner(userId) || isAdminUser();
      
      // API calls subcollection
      match /apiCalls/{callId} {
        allow read: if isOwner(userId) || isAdminUser();
        allow write: if isOwner(userId) || isAdminUser();
      }
      
      // Cost budgets subcollection
      match /budgets/{budgetId} {
        allow read: if isOwner(userId) || isAdminUser();
        allow write: if isOwner(userId) || isAdminUser();
      }
      
      // Cost analytics subcollection
      match /analytics/{period} {
        allow read: if isOwner(userId) || isAdminUser();
        allow write: if isOwner(userId) || isAdminUser();
      }
    }
  }
}